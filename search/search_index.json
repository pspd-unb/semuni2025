{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introdu\u00e7\u00e3o a programa\u00e7\u00e3o de aplica\u00e7\u00f5es em nuvem","text":"<p>Bem-vindo ao curso de Introdu\u00e7\u00e3o a programa\u00e7\u00e3o de aplica\u00e7\u00f5es em nuvem! Este curso apresenta uma vis\u00e3o introdut\u00f3ria sobre as principais tecnologias utilizadas atualmente para o desenvolvimento de aplica\u00e7\u00f5es de larga escala em nuvem.</p>"},{"location":"#objetivos-do-curso","title":"Objetivos do Curso","text":"<p>Objetivo Geral</p> <p>O objetivo geral dessa oficina/curso \u00e9 que o aluno compreenda as principais tecnologias utilizadas para constru\u00e7\u00e3o de aplica\u00e7\u00f5es de larga escala e aprenda alguns paradigmas de programa\u00e7\u00e3o paralela e distribu\u00edda.</p>"},{"location":"#objetivos-especificos","title":"Objetivos Espec\u00edficos","text":"<p>Ao final deste curso, voc\u00ea ser\u00e1 capaz de:</p> <ul> <li>Experimentar a constru\u00e7\u00e3o de aplica\u00e7\u00f5es distribu\u00eddas (utilizando linguagem C b\u00e1sica)</li> <li>Experimentar a constru\u00e7\u00e3o de aplica\u00e7\u00f5es paralelas, usando os n\u00facleos de processamento dos processadores e GPUs</li> <li>Conhecer o Kubernetes como ferramenta de DevOps para desenvolvimento de aplica\u00e7\u00f5es distribu\u00eddas/paralelas</li> </ul>"},{"location":"#programa-do-curso","title":"Programa do Curso","text":"M\u00f3dulo 1: Introdu\u00e7\u00e3oM\u00f3dulo 2: Programa\u00e7\u00e3o Distribu\u00eddaM\u00f3dulo 3: Programa\u00e7\u00e3o ParalelaM\u00f3dulo 4: Cloud Native &amp; Kubernetes <ul> <li>Vis\u00e3o Geral: Aplica\u00e7\u00f5es e arquiteturas paralelas e distribu\u00eddas</li> <li>Arquiteturas Paralelas: Conceitos e implementa\u00e7\u00f5es</li> <li>Arquiteturas Distribu\u00eddas: Fundamentos e padr\u00f5es</li> </ul> <ul> <li>MPI: Message Passing Interface para programa\u00e7\u00e3o distribu\u00edda</li> <li>Brokers: Sistemas de mensageria e comunica\u00e7\u00e3o</li> <li>xRPC: Remote Procedure Calls e protocolos de comunica\u00e7\u00e3o</li> </ul> <ul> <li>OpenMP: Programa\u00e7\u00e3o paralela em mem\u00f3ria compartilhada</li> <li>GPUs: Computa\u00e7\u00e3o paralela em placas gr\u00e1ficas</li> <li>Paralelismo em C: Implementa\u00e7\u00f5es pr\u00e1ticas usando linguagem C</li> </ul> <ul> <li>Cloud Native: Conceitos e metodologias</li> <li>Kubernetes: Orquestra\u00e7\u00e3o de containers</li> <li>DevOps: Kubernetes como ferramenta de DevOps para deploy</li> </ul>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Para aproveitar ao m\u00e1ximo este curso, voc\u00ea precisar\u00e1 de:</p> <ol> <li>Conhecimentos b\u00e1sicos em programa\u00e7\u00e3o (especialmente linguagem C)</li> <li>Familiaridade com conceitos b\u00e1sicos de sistemas operacionais</li> <li>Interesse em tecnologias de alta performance e larga escala</li> </ol> <p>Dica Importante</p> <p>Este curso combina teoria e pr\u00e1tica intensiva. Prepare-se para experimentar e implementar aplica\u00e7\u00f5es paralelas e distribu\u00eddas!</p>"},{"location":"#resultados-esperados","title":"Resultados Esperados","text":"<p>Ao concluir o curso</p> <p>Espera-se que os estudantes saiam com conhecimento suficiente para se envolverem em projetos que exijam n\u00edvel m\u00ednimo de conhecimento sobre tecnologias voltadas para aplica\u00e7\u00f5es de larga escala.</p>"},{"location":"#tecnologias-e-palavras-chave","title":"Tecnologias e Palavras-Chave","text":"Categoria Tecnologias/Conceitos Programa\u00e7\u00e3o C, OpenMP, MPI Paralelismo GPUs, Processamento Multi-core Distribui\u00e7\u00e3o Brokers, xRPC, Message Passing Cloud Native Microsservi\u00e7os, DevOps, Docker, Kubernetes Conceitos-Chave Programa\u00e7\u00e3o Paralela, Programa\u00e7\u00e3o Distribu\u00edda"},{"location":"#cronograma-do-curso","title":"Cronograma do Curso","text":"<p>Informa\u00e7\u00f5es Gerais</p> <p>Per\u00edodo: 03 a 07 de Novembro de 2025 Modalidade: Curso intensivo presencial Local: Universidade de Bras\u00edlia</p>"},{"location":"#cronograma","title":"Cronograma","text":"Data T\u00f3pico Dura\u00e7\u00e3o 03/11 - 05/11 Apresenta\u00e7\u00e3o sobre aplica\u00e7\u00f5es e arquiteturas paralelas e distribu\u00eddas (MPI e OpenMP) 3 dias 05/11 Conhecendo GPUs e outros paradigmas de programa\u00e7\u00e3o paralela 1 dia 06/11 - 07/11 Cloud Native e DevOps com Kubernetes 2 dias"},{"location":"#instrutores","title":"Instrutores","text":"<ul> <li> <p> Prof. Dr. Fernando William Cruz</p> <p></p> <p>Coordenador do Curso</p> <p>Professor da FCTE/UnB</p> </li> <li> <p> Bruno Martins</p> <p></p> <p>Membro da Equipe</p> <p>Graduando em Engenharia de Software (FCTE/UnB)  </p> </li> <li> <p> Thiago Vivan</p> <p></p> <p>Membro da Equipe</p> <p>Graduando em Engenharia de Software (FCTE/UnB)  </p> </li> </ul>"},{"location":"#recursos-adicionais","title":"Recursos Adicionais","text":"<ul> <li>OpenMP Documentation</li> <li>MPI Tutorial</li> <li>Kubernetes Documentation</li> <li>CUDA Programming Guide</li> </ul> <p>Importante</p> <p>Este \u00e9 um curso intensivo que requer dedica\u00e7\u00e3o para experimenta\u00e7\u00e3o pr\u00e1tica. Certifique-se de ter conhecimentos b\u00e1sicos de programa\u00e7\u00e3o em C antes de iniciar.</p> <p>Universidade de Bras\u00edlia - 2025</p>"},{"location":"modulo4/ci-cd/","title":"CI/CD","text":""},{"location":"modulo4/cloud-native/","title":"Introdu\u00e7\u00e3o ao Cloud Native","text":"<p>Cloud native \u00e9 uma abordagem fundamental para construir e executar aplica\u00e7\u00f5es escal\u00e1veis que aproveitam ao m\u00e1ximo os servi\u00e7os e modelos de entrega baseados em nuvem. O termo se refere menos ao local onde a aplica\u00e7\u00e3o est\u00e1 hospedada e mais a como ela \u00e9 constru\u00edda e implantada. Ser cloud native envolve adaptar-se \u00e0s novas possibilidades e limita\u00e7\u00f5es oferecidas pela nuvem em compara\u00e7\u00e3o com a infraestrutura tradicional local (on-premises).</p> <p>Cloud native \u00e9 frequentemente citado como o objetivo final para a constru\u00e7\u00e3o ou migra\u00e7\u00e3o de aplica\u00e7\u00f5es hoje. \u00c9 um termo \u00fatil para descrever sistemas distribu\u00eddos, baseados em nuvem, containerizados e compostos por microsservi\u00e7os cooperativos, gerenciados dinamicamente por infraestrutura automatizada como c\u00f3digo.</p>"},{"location":"modulo4/cloud-native/#arquitetura-e-principios-cloud-native","title":"Arquitetura e Princ\u00edpios Cloud Native","text":"<p>Uma caracter\u00edstica principal da arquitetura cloud native \u00e9 o contraste com aplica\u00e7\u00f5es tradicionais e monol\u00edticas.</p> <ul> <li>Monol\u00edtico vs. Cloud Native: Aplica\u00e7\u00f5es monol\u00edticas tradicionais precisam ser constru\u00eddas, testadas e implantadas como uma \u00fanica unidade, criando depend\u00eancias pr\u00f3ximas que dificultam mudan\u00e7as, testes, implanta\u00e7\u00f5es e opera\u00e7\u00e3o \u00e0 medida que crescem. Em contraste, arquiteturas cloud native decomp\u00f5em componentes em servi\u00e7os fracamente acoplados para ajudar a gerenciar a complexidade e melhorar a velocidade, a agilidade e a escala da entrega de software. Aplica\u00e7\u00f5es cloud native s\u00e3o projetadas desde o in\u00edcio para aproveitar a natureza distribu\u00edda e el\u00e1stica da nuvem.</li> </ul> <p>O objetivo fundamental das arquiteturas cloud native \u00e9 aumentar a velocidade de entrega de software e a confiabilidade dos servi\u00e7os, ao mesmo tempo em que desenvolve uma cultura de responsabilidade compartilhada entre os participantes do desenvolvimento. Essa abordagem se apoia em v\u00e1rios pilares fundamentais ou blocos tecnol\u00f3gicos:</p>"},{"location":"modulo4/cloud-native/#1-microsservicos","title":"1. Microsservi\u00e7os","text":"<p>Microsservi\u00e7os s\u00e3o componentes ou servi\u00e7os discretos e reutiliz\u00e1veis que comp\u00f5em uma \u00fanica aplica\u00e7\u00e3o.</p> <ul> <li>Composi\u00e7\u00e3o: Microsservi\u00e7os dividem uma aplica\u00e7\u00e3o em servi\u00e7os menores e leves que podem ser facilmente compostos e conectados por meio de APIs (Application Programming Interfaces).</li> <li>Independ\u00eancia: Eles s\u00e3o fracamente acoplados e implant\u00e1veis de forma independente. Isso permite que equipes implantem e escalem componentes separadamente.</li> <li>Pilha Tecnol\u00f3gica: Microsservi\u00e7os geralmente possuem sua pr\u00f3pria pilha tecnol\u00f3gica, incluindo banco de dados e modelo de dados, e se comunicam via APIs REST, message brokers ou event streaming.</li> <li>Resili\u00eancia: Por serem independentes, se um microsservi\u00e7o falhar, a aplica\u00e7\u00e3o como um todo pode continuar funcionando.</li> </ul>"},{"location":"modulo4/cloud-native/#2-containers-e-orquestracao","title":"2. Containers e Orquestra\u00e7\u00e3o","text":"<p>Containers s\u00e3o as unidades de computa\u00e7\u00e3o de facto das aplica\u00e7\u00f5es cloud native modernas.</p> <ul> <li>Containers: S\u00e3o componentes leves e execut\u00e1veis que empacotam o c\u00f3digo-fonte da aplica\u00e7\u00e3o (c\u00f3digo dos microsservi\u00e7os) junto com todos os elementos necess\u00e1rios, incluindo depend\u00eancias e bibliotecas do sistema operacional, para executar o c\u00f3digo de forma consistente em qualquer ambiente.</li> <li>Portabilidade: Containers proporcionam portabilidade de carga de trabalho, apoiando o conceito de \u201cconstrua uma vez, execute em qualquer lugar\u201d, o que facilita bastante o desenvolvimento e a implanta\u00e7\u00e3o.</li> <li>Efici\u00eancia: Containers s\u00e3o menores, mais eficientes em recursos e mais port\u00e1teis que m\u00e1quinas virtuais (VMs). Eles executam diretamente na CPU real, sem a sobrecarga da virtualiza\u00e7\u00e3o.</li> <li>Orquestra\u00e7\u00e3o (ex.: Kubernetes): \u00c0 medida que o n\u00famero de microsservi\u00e7os cresce, plataformas de orquestra\u00e7\u00e3o de containers como o Kubernetes tornam-se essenciais para gerenciar containers em escala. O Kubernetes oferece supervis\u00e3o, controle sobre implanta\u00e7\u00e3o, reparo de falhas e balanceamento de carga entre containers. Ele abstrai detalhes espec\u00edficos da nuvem, fornecendo uma defini\u00e7\u00e3o port\u00e1til de como o software deve ser executado.</li> </ul>"},{"location":"modulo4/cloud-native/#3-devops","title":"3. DevOps","text":"<p>DevOps \u00e9 uma mudan\u00e7a cultural e metodol\u00f3gica essencial para o desenvolvimento de aplica\u00e7\u00f5es cloud native.</p> <ul> <li>Colabora\u00e7\u00e3o e Automa\u00e7\u00e3o: DevOps envolve a colabora\u00e7\u00e3o entre equipes de desenvolvimento e opera\u00e7\u00f5es de TI para automatizar processos de infraestrutura e entrega de software.</li> <li>Prop\u00f3sito Compartilhado: Cria uma cultura onde as equipes se comunicam em torno de um prop\u00f3sito comum, permitindo que aplica\u00e7\u00f5es sejam constru\u00eddas, testadas e lan\u00e7adas mais rapidamente.</li> <li>Infraestrutura como C\u00f3digo: DevOps traz habilidades de desenvolvimento para a opera\u00e7\u00e3o, utilizando ferramentas e fluxos de trabalho que automatizam o provisionamento da infraestrutura na nuvem.</li> </ul>"},{"location":"modulo4/cloud-native/#4-integracao-continua-e-entrega-continua-cicd","title":"4. Integra\u00e7\u00e3o Cont\u00ednua e Entrega Cont\u00ednua (CI/CD)","text":"<p>Pipelines de CI/CD dependem fortemente de automa\u00e7\u00e3o para otimizar o processo de entrega de software.</p> <ul> <li>CI (Continuous Integration): Envolve desenvolvedores integrando com frequ\u00eancia pequenas altera\u00e7\u00f5es em uma base de c\u00f3digo compartilhada, permitindo identificar e resolver problemas mais rapidamente.</li> <li>CD (Continuous Delivery): Automatiza a constru\u00e7\u00e3o, o teste e a implanta\u00e7\u00e3o de altera\u00e7\u00f5es de aplica\u00e7\u00e3o sem necessidade de per\u00edodos de inatividade programados. Isso garante lan\u00e7amentos mais confi\u00e1veis e menos arriscados, possibilitando entregas r\u00e1pidas e frequentes de novos servi\u00e7os.</li> </ul>"},{"location":"modulo4/cloud-native/#5-apis-declarativas-e-infraestrutura-imutavel","title":"5. APIs Declarativas e Infraestrutura Imut\u00e1vel","text":"<p>Aplica\u00e7\u00f5es cloud native aproveitam conceitos tecnol\u00f3gicos modernos em sua arquitetura:</p> <ul> <li>APIs Declarativas: Sistemas cloud native usam APIs para conectar microsservi\u00e7os fracamente acoplados. Uma API declarativa especifica o que um servi\u00e7o deseja de dados e quais resultados pode fornecer, em vez de definir os passos exatos para atingir o resultado.</li> <li>Infraestrutura Imut\u00e1vel: Esse princ\u00edpio significa que os servidores que hospedam aplica\u00e7\u00f5es cloud native permanecem inalterados ap\u00f3s a implanta\u00e7\u00e3o. Se for necess\u00e1rio mudar algo, o servidor antigo \u00e9 descartado e a aplica\u00e7\u00e3o \u00e9 movida para um novo servidor de alto desempenho, tornando o processo de implanta\u00e7\u00e3o previs\u00edvel.</li> </ul>"},{"location":"modulo4/cloud-native/#beneficios-do-cloud-native","title":"Benef\u00edcios do Cloud Native","text":"<p>A abordagem cloud native oferece diversos benef\u00edcios:</p> Categoria Benef\u00edcios Espec\u00edficos Velocidade e Agilidade Aumenta a produtividade e a velocidade dos desenvolvedores. Permite inova\u00e7\u00e3o mais r\u00e1pida devido a servi\u00e7os menores e fracamente acoplados, possibilitando que equipes trabalhem de forma aut\u00f4noma. Facilita a constru\u00e7\u00e3o, teste e implanta\u00e7\u00e3o r\u00e1pidos, levando produtos ao mercado mais rapidamente. Confiabilidade e Disponibilidade Proporciona alta disponibilidade e resili\u00eancia, pois reduz a complexidade operacional e oferece autoscaling e self-healing. As implanta\u00e7\u00f5es tornam-se mais confi\u00e1veis e menos arriscadas. Escalabilidade Alcan\u00e7a maior escalabilidade com automa\u00e7\u00e3o de infraestrutura, balanceando carga conforme a demanda e permitindo que equipes otimizem custo e desempenho. Efici\u00eancia de Custos Reduz significativamente os custos operacionais ao permitir compartilhamento de recursos e consumo sob demanda. Diminui despesas operacionais de longo prazo (OpEx), j\u00e1 que o investimento em manuten\u00e7\u00e3o de infraestrutura f\u00edsica \u00e9 reduzido. Portabilidade e Seguran\u00e7a Aplica\u00e7\u00f5es cloud native s\u00e3o projetadas para rodar praticamente em qualquer lugar, facilitando sua migra\u00e7\u00e3o entre ambientes. Elas reduzem a superf\u00edcie de ataque e s\u00e3o mais f\u00e1ceis de atualizar e corrigir, resultando em maior seguran\u00e7a."},{"location":"modulo4/cloud-native/#desafios-do-cloud-native","title":"Desafios do Cloud Native","text":"<p>Apesar das vantagens, adotar o modelo cloud native apresenta alguns desafios e compensa\u00e7\u00f5es:</p> <ul> <li>Resist\u00eancia Cultural: A implementa\u00e7\u00e3o bem-sucedida exige mudan\u00e7as culturais significativas, indo al\u00e9m da ado\u00e7\u00e3o de novas ferramentas. Pode haver resist\u00eancia em adotar as melhores pr\u00e1ticas de DevOps.</li> <li>Complexidade de Sistemas Distribu\u00eddos: Lidar com sistemas distribu\u00eddos e in\u00fameros componentes pode ser desafiador se as ferramentas ou processos corretos para gerenciamento, desenvolvimento, teste e implanta\u00e7\u00e3o n\u00e3o estiverem bem estabelecidos. \u00c9 necess\u00e1rio administrar muitos servi\u00e7os pequenos e discretos, em vez de uma \u00fanica aplica\u00e7\u00e3o.</li> <li>Gest\u00e3o de Custos: H\u00e1 risco de aumento nos custos operacionais e tecnol\u00f3gicos sem estrat\u00e9gias adequadas de monitoramento e otimiza\u00e7\u00e3o do uso de recursos em ambientes de nuvem.</li> <li>Lacuna de Habilidades: Pode faltar pessoal com as compet\u00eancias tecnol\u00f3gicas necess\u00e1rias para trabalhar e integrar uma pilha tecnol\u00f3gica cloud native mais complexa.</li> </ul> <p>Cloud native \u00e9 considerado uma jornada cont\u00ednua de itera\u00e7\u00e3o e melhoria constante, e n\u00e3o um projeto \u00fanico de m\u00faltiplos anos. Organiza\u00e7\u00f5es que simplesmente adotam uma abordagem de \u201clift and shift\u201d \u2014 migrando aplica\u00e7\u00f5es sem reestrutur\u00e1-las com base nos princ\u00edpios cloud native \u2014 perder\u00e3o muitos dos benef\u00edcios potenciais.</p>"},{"location":"modulo4/cloud-native/#bibliografia","title":"Bibliografia","text":"<p>[1] ARUDEL, John; DOMINGUS, Justin. Cloud Native DevOps with Kubernetes: Building, Deploying and Scaling Modern Applications in the Cloud. 1. ed. O'Reilly, 2019.</p> <p>[2] Google Cloud. What is cloud native?. Dispon\u00edvel em: https://cloud.google.com/learn/what-is-cloud-native?hl=en. Acesso em: 29 out. 2025.</p> <p>[3] IBM. What is cloud native?. Dispon\u00edvel em: https://www.ibm.com/think/topics/cloud-native. Acesso em: 29 out. 2025.</p> <p>[4] AWS. What is cloud native?. Dispon\u00edvel em: https://aws.amazon.com/what-is/cloud-native/. Acesso em: 29 out. 2025.</p>"},{"location":"modulo4/desafio1/","title":"\ud83d\ude80 Desafio 1: Do Dev ao Deploy - Containerize Tudo!","text":""},{"location":"modulo4/desafio1/#seu-desafio","title":"\ud83c\udfaf Seu Desafio","text":"<p>Bem-vindo ao Desafio 1! Aqui voc\u00ea vai colocar a m\u00e3o na massa e transformar uma aplica\u00e7\u00e3o completa em um ambiente totalmente containerizado, automatizado e pronto para produ\u00e7\u00e3o. </p> <p>Voc\u00ea recebeu uma aplica\u00e7\u00e3o Django + Next.js que funciona... mas s\u00f3 localmente. Seu desafio? Fazer ela rodar em containers, criar pipelines de CI/CD e preparar tudo para um deploy profissional! \ud83d\udcaa</p>"},{"location":"modulo4/desafio1/#regras-do-jogo","title":"\ud83c\udfae Regras do Jogo","text":"<p>Como Jogar</p> <ul> <li>Cada fase do desafio deve ser conclu\u00edda em um commit separado</li> <li>Sua aplica\u00e7\u00e3o deve funcionar no final de cada etapa</li> <li>Use os tutoriais como guias, mas sinta-se livre para explorar!</li> <li>Trabalhe no seu pr\u00f3prio ritmo, mas complete todas as fases</li> </ul> <p>Prepare seu Ambiente</p> <p>Antes de come\u00e7ar, fa\u00e7a um fork do reposit\u00f3rio original e crie seu pr\u00f3prio reposit\u00f3rio privado. Assim voc\u00ea pode experimentar \u00e0 vontade sem medo de errar!</p>"},{"location":"modulo4/desafio1/#fases-do-desafio","title":"\ud83c\udfae Fases do Desafio","text":""},{"location":"modulo4/desafio1/#fase-1-containerize-o-ambiente-de-dev","title":"\ud83d\udc33 Fase 1: Containerize o Ambiente de DEV","text":"<p>Objetivo: Transformar sua aplica\u00e7\u00e3o em containers que rodam perfeitamente no seu ambiente de desenvolvimento!</p> <p>Sua aplica\u00e7\u00e3o tem duas partes: um backend em Django e um frontend em Next.js. Atualmente ela usa SQLite, mas voc\u00ea vai precisar do Postgres.</p> <p>Miss\u00e3o: - Crie um <code>Dockerfile</code> para o backend (Django) - Crie um <code>Dockerfile</code> para o frontend (Next.js) - Configure tudo em modo desenvolvimento com:     - \u2705 Debug habilitado     - \u2705 Hot reload ativado (suas mudan\u00e7as no c\u00f3digo aparecem instantaneamente!)     - \u2705 Vari\u00e1veis de ambiente para DEV</p> <p>Checkpoint</p> <p>Ao final desta fase, voc\u00ea deve conseguir rodar cada container individualmente e ver suas mudan\u00e7as de c\u00f3digo refletidas imediatamente!</p>"},{"location":"modulo4/desafio1/#fase-2-orquestre-tudo-com-docker-compose-dev","title":"\ud83c\udfbc Fase 2: Orquestre Tudo com Docker Compose (DEV)","text":"<p>Objetivo: Fazer todos os servi\u00e7os conversarem entre si!</p> <p>Miss\u00e3o: - Crie um arquivo <code>docker-compose.yml</code> que combine:     - \ud83c\udfa8 Container do Frontend     - \ud83d\udd27 Container do Backend     - \ud83d\uddc4\ufe0f Container do Postgres - Configure as redes para que tudo se comunique</p> <p>Checkpoint</p> <p>Vit\u00f3ria! Com um simples <code>docker compose up</code>, toda sua aplica\u00e7\u00e3o deve subir funcionando perfeitamente! \ud83c\udf89</p>"},{"location":"modulo4/desafio1/#fase-3-pipeline-de-ci-automatize-a-qualidade","title":"\u2699\ufe0f Fase 3: Pipeline de CI - Automatize a Qualidade","text":"<p>Objetivo: Criar um pipeline que verifica automaticamente se seu c\u00f3digo est\u00e1 em ordem!</p> <p>Miss\u00e3o: Configure o Gitlab CI com as seguintes etapas:</p> 3.1 Build \ud83d\udd283.2 Testes \ud83e\uddea3.3 Lint \ud83e\uddf9 <p>Garanta que sua aplica\u00e7\u00e3o compila sem erros</p> <p>Crie testes unit\u00e1rios simples para:</p> <ul> <li>Frontend (pelo menos 1 teste)</li> <li>Backend (pelo menos 1 teste)</li> </ul> <p>Configure linters para manter seu c\u00f3digo limpo e padronizado</p> <p>Desafio Extra</p> <p>Mostre que seu pipeline funciona! Fa\u00e7a commits que:</p> <ol> <li>\u274c Quebram o build (e veja o pipeline falhar)</li> <li>\u274c Falham nos testes</li> <li>\u274c N\u00e3o passam no lint</li> <li>\u2705 Passam em tudo!</li> </ol>"},{"location":"modulo4/desafio1/#fase-4-containers-de-producao-otimize","title":"\ud83c\udfed Fase 4: Containers de PRODU\u00c7\u00c3O - Otimize!","text":"<p>Objetivo: Criar containers otimizados e seguros para produ\u00e7\u00e3o!</p> <p>Miss\u00e3o: - Crie novos <code>Dockerfiles</code> baseados em Alpine Linux (super leve!) - Configure tudo em modo produ\u00e7\u00e3o:     - \u274c Debug desabilitado     - \u2705 C\u00f3digo otimizado e minificado     - \u2705 Build dos arquivos est\u00e1ticos do frontend     - \u2705 Tudo autocontido nos containers</p> <p>Pro Tip</p> <p>Containers de produ\u00e7\u00e3o devem ser leves, r\u00e1pidos e seguros. Pense em tamanho e seguran\u00e7a!</p>"},{"location":"modulo4/desafio1/#fase-5-stack-completo-de-producao","title":"\ud83d\ude80 Fase 5: Stack Completo de PRODU\u00c7\u00c3O","text":"<p>Objetivo: Monte a stack completa pronta para o mundo real!</p> <p>Miss\u00e3o: Crie o <code>docker-compose-prod.yml</code> com:</p> <ul> <li>\ud83c\udfa8 Frontend servido pelo Nginx</li> <li>\ud83d\udd27 Backend em produ\u00e7\u00e3o</li> <li>\ud83d\uddc4\ufe0f Postgres com credenciais de produ\u00e7\u00e3o (n\u00e3o use as mesmas de DEV!)</li> <li>\ud83d\udd12 SSL configurado (HTTPS na porta 443)</li> <li>\ud83d\udd04 Redirecionamento de HTTP (80) para HTTPS (443)</li> </ul> <p>Checkpoint Final de Produ\u00e7\u00e3o</p> <p>Sua aplica\u00e7\u00e3o deve:</p> <ul> <li>\u2705 Subir com <code>docker compose -f docker-compose-prod.yml up</code></li> <li>\u2705 Ser acess\u00edvel APENAS via HTTPS</li> <li>\u2705 N\u00e3o expor portas desnecess\u00e1rias</li> <li>\u2705 Estar segura e otimizada!</li> </ul>"},{"location":"modulo4/desafio1/#fase-6-deploy-continuo-automatize-tudo","title":"\ud83c\udfaf Fase 6: Deploy Cont\u00ednuo - Automatize Tudo!","text":"<p>Objetivo: O grand finale! Deploy autom\u00e1tico ap\u00f3s passar no CI!</p> <p>Miss\u00e3o: - Configure o CD para publicar automaticamente suas imagens no Container Registry do Gitlab - O deploy s\u00f3 deve acontecer se TODAS as etapas de CI passarem - Publique as imagens de produ\u00e7\u00e3o do frontend e backend</p> <p>\ud83c\udfc6 Desafio Completo!</p> <p>Parab\u00e9ns! Voc\u00ea criou um pipeline completo de DevOps, do desenvolvimento ao deploy automatizado! \ud83c\udf8a</p>"},{"location":"modulo4/desafio1/#checklist-do-desafio","title":"\ud83d\udcca Checklist do Desafio","text":"<p>Acompanhe seu progresso:</p> Fase Descri\u00e7\u00e3o Status \ud83d\udc33 Fase 1 Containeriza\u00e7\u00e3o da Aplica\u00e7\u00e3o (DEV) \u2b1c \ud83c\udfbc Fase 2 Docker Compose - Stack Completa (DEV) \u2b1c \u2699\ufe0f Fase 3 Integra\u00e7\u00e3o Cont\u00ednua (CI) \u2b1c \u00a0\u00a0\u00a0\u21b3 3.1 Build automatizado \u2b1c \u00a0\u00a0\u00a0\u21b3 3.2 Testes unit\u00e1rios \u2b1c \u00a0\u00a0\u00a0\u21b3 3.3 Lint do c\u00f3digo \u2b1c \ud83c\udfed Fase 4 Containers Otimizados (PROD) \u2b1c \ud83d\ude80 Fase 5 Stack Completa com SSL (PROD) \u2b1c \ud83c\udfaf Fase 6 Deploy Cont\u00ednuo (CD) \u2b1c <p>Dica de Ouro</p> <p>N\u00e3o tenha pressa! \u00c9 melhor completar cada fase com qualidade do que correr e ficar preso depois. Cada fase constr\u00f3i sobre a anterior! \ud83c\udfd7\ufe0f</p>"},{"location":"modulo4/desafio1/#sobre-o-projeto-base","title":"\ud83d\udce6 Sobre o Projeto Base","text":"<p>Voc\u00ea vai trabalhar com uma aplica\u00e7\u00e3o fullstack moderna: Django + Next.js</p>"},{"location":"modulo4/desafio1/#estrutura-do-projeto","title":"\ud83d\uddc2\ufe0f Estrutura do Projeto","text":"<p>O projeto est\u00e1 organizado como um monorepo (tudo em um s\u00f3 lugar!):</p> <pre><code>.\n\u251c\u2500\u2500 api                          # Backend Django\n\u2502   \u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 core_apps\n\u2502   \u251c\u2500\u2500 manage.py\n\u2502   \u251c\u2500\u2500 pytest.ini\n\u2502   \u2514\u2500\u2500 requirements.txt\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 web                          # Frontend NextJS\n    \u251c\u2500\u2500 components.json\n    \u251c\u2500\u2500 next.config.mjs\n    \u251c\u2500\u2500 package.json\n    \u251c\u2500\u2500 package-lock.json\n    \u251c\u2500\u2500 public\n    \u251c\u2500\u2500 src\n    \u251c\u2500\u2500 tsconfig.json\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"modulo4/desafio1/#quer-testar-localmente-primeiro","title":"\ud83c\udfc3 Quer Testar Localmente Primeiro?","text":"<p>Antes de containerizar, voc\u00ea pode rodar a aplica\u00e7\u00e3o localmente para entender como ela funciona!</p>"},{"location":"modulo4/desafio1/#pre-requisitos","title":"\ud83d\udd27 Pr\u00e9-requisitos","text":"<p>Ferramentas Necess\u00e1rias</p> <ul> <li>Python 3.11+</li> <li>Node.js 20+ e npm</li> <li>Git</li> </ul>"},{"location":"modulo4/desafio1/#clone-o-projeto","title":"\ud83d\udce5 Clone o Projeto","text":"<pre><code>git clone https://github.com/FGA-GCES/trabalho-individual-2024-2.git\ncd trabalho-individual-2024-2\n</code></pre>"},{"location":"modulo4/desafio1/#configurando-o-backend-django","title":"\ud83d\udd27 Configurando o Backend (Django)","text":"<pre><code># Entre no diret\u00f3rio do backend\ncd api\n\n# Criar e ativar um ambiente virtual (Linux/MacOS)\npython -m venv venv\nsource venv/bin/activate\n\n# No Windows:\n???\n\n# Instale as depend\u00eancias\npip install -r requirements.txt\n\n# Execute as migra\u00e7\u00f5es\npython manage.py migrate\n\n# Inicie o servidor de desenvolvimento\npython manage.py runserver\n</code></pre> <p>Backend Rodando!</p> <p>Acesse: <code>http://localhost:8000</code> \u2705</p>"},{"location":"modulo4/desafio1/#configurando-o-frontend-nextjs","title":"\ud83c\udfa8 Configurando o Frontend (Next.js)","text":"<pre><code># Entre no diret\u00f3rio do frontend\ncd web\n\n# Instale as depend\u00eancias\nnpm install\n\n# Crie um arquivo .env.local baseado no exemplo\ncp .env.example .env.local\n\n# Inicie o servidor de desenvolvimento\nnpm run dev\n</code></pre> <p>Frontend Rodando!</p> <p>Acesse: <code>http://localhost:3000</code> \ud83c\udf89</p>"},{"location":"modulo4/desafio1/#dicas-para-o-sucesso","title":"\ud83c\udf93 Dicas para o Sucesso","text":"<p>Estrat\u00e9gias Vencedoras</p> <p>\ud83d\udcd6 Leia a Documenta\u00e7\u00e3o: Docker e Gitlab CI t\u00eam \u00f3timas docs - use-as!</p> <p>\ud83d\udd0d Debug Incrementalmente: Teste cada pequena mudan\u00e7a antes de avan\u00e7ar</p> <p>\ud83d\udcbe Commit Frequentemente: Pequenos commits funcionais s\u00e3o seus amigos</p> <p>\ud83e\udd1d Colabore: Stuck? Pergunte! DevOps \u00e9 sobre colabora\u00e7\u00e3o</p> <p>\ud83e\uddea Teste Localmente: Sempre teste localmente antes de fazer push</p> <p>Armadilhas Comuns</p> <ul> <li>\u26a0\ufe0f N\u00e3o usar as mesmas credenciais de DEV em PROD</li> <li>\u26a0\ufe0f Esquecer de expor as portas corretas nos containers</li> <li>\u26a0\ufe0f N\u00e3o configurar as vari\u00e1veis de ambiente adequadamente</li> <li>\u26a0\ufe0f Ignorar os logs quando algo falha</li> </ul>"},{"location":"modulo4/desafio1/#criterios-de-sucesso","title":"\ud83c\udfc6 Crit\u00e9rios de Sucesso","text":"<p>Voc\u00ea completou o desafio quando:</p> <p>\u2705 Todos os containers funcionam perfeitamente \u2705 O pipeline de CI/CD est\u00e1 verde \u2705 A aplica\u00e7\u00e3o roda em modo produ\u00e7\u00e3o com SSL \u2705 Voc\u00ea consegue fazer deploy automatizado \u2705 O c\u00f3digo est\u00e1 documentado e organizado  </p> <p>Boa sorte, e que a for\u00e7a do Docker esteja com voc\u00ea! \ud83d\udc33\u2728</p>"},{"location":"modulo4/desafio2/","title":"Desafio 2","text":""},{"location":"modulo4/docker-pratica/","title":"Containeriza\u00e7\u00e3o","text":""},{"location":"modulo4/docker-teoria/","title":"Containeriza\u00e7\u00e3o","text":""},{"location":"modulo4/docker-teoria/#i-containerizacao-e-containers","title":"I. Containeriza\u00e7\u00e3o e Containers","text":"<p>Containeriza\u00e7\u00e3o \u00e9 um m\u00e9todo de implantar aplica\u00e7\u00f5es de software executando-as em ambientes isolados chamados containers. Essa abordagem abstrai as aplica\u00e7\u00f5es do ambiente em que elas rodam, permitindo implanta\u00e7\u00e3o f\u00e1cil e consistente \u2014 seja em um data center privado, em uma nuvem p\u00fablica ou na m\u00e1quina local de um desenvolvedor.</p>"},{"location":"modulo4/docker-teoria/#o-que-sao-containers","title":"O que s\u00e3o Containers?","text":"<p>Containers s\u00e3o processos isolados que executam componentes de uma aplica\u00e7\u00e3o. Eles s\u00e3o inst\u00e2ncias execut\u00e1veis de uma imagem, fornecendo um ambiente protegido (sandbox). Containers aproveitam os mecanismos de baixo n\u00edvel do sistema operacional (SO) hospedeiro, geralmente usando virtualiza\u00e7\u00e3o em n\u00edvel de sistema operacional no Linux, para alcan\u00e7ar o isolamento. O Docker utiliza uma tecnologia chamada namespaces para fornecer esse espa\u00e7o de trabalho isolado.</p>"},{"location":"modulo4/docker-teoria/#containers-vs-maquinas-virtuais-vms","title":"Containers vs. M\u00e1quinas Virtuais (VMs)","text":"<p>A abordagem com containers difere significativamente do uso de m\u00e1quinas virtuais:</p> <ul> <li>VMs executam aplica\u00e7\u00f5es dentro de um sistema operacional convidado separado, o que requer a virtualiza\u00e7\u00e3o de hardware sobre o sistema operacional hospedeiro. Isso gera uma sobrecarga computacional consider\u00e1vel.</li> <li>Containers s\u00e3o leves e compartilham o kernel do sistema operacional hospedeiro. Eles cont\u00eam tudo o que \u00e9 necess\u00e1rio para executar a aplica\u00e7\u00e3o (arquivos, bin\u00e1rios, bibliotecas e configura\u00e7\u00f5es), sem depender de depend\u00eancias pr\u00e9-instaladas no host. Isso permite melhor aproveitamento de recursos e a execu\u00e7\u00e3o de mais aplica\u00e7\u00f5es em menos infraestrutura.</li> </ul>"},{"location":"modulo4/docker-teoria/#caracteristicas-dos-containers","title":"Caracter\u00edsticas dos Containers","text":"<p>Containers s\u00e3o valorizados por sua consist\u00eancia e efici\u00eancia:</p> <ul> <li>Autossuficientes: Cada container possui todos os arquivos e depend\u00eancias de que precisa para funcionar.</li> <li>Isolados: Containers rodam de forma isolada, reduzindo sua influ\u00eancia no host e em outros containers, aumentando a seguran\u00e7a.</li> <li>Port\u00e1teis: Containers podem ser executados em qualquer ambiente de forma consistente, oferecendo portabilidade de carga de trabalho e apoiando o conceito de \u201cconstrua uma vez, execute em qualquer lugar\u201d.</li> <li>Independentes: Cada container \u00e9 gerenciado de forma independente; excluir um container n\u00e3o afeta os demais.</li> </ul>"},{"location":"modulo4/docker-teoria/#ii-docker-a-plataforma","title":"II. Docker: A Plataforma","text":"<p>Docker \u00e9 definido como um projeto open source e uma plataforma aberta para desenvolver, empacotar e executar aplica\u00e7\u00f5es. \u00c9 uma ferramenta que automatiza a implanta\u00e7\u00e3o de software dentro de containers. O principal benef\u00edcio do Docker \u00e9 permitir que usu\u00e1rios empacotem uma aplica\u00e7\u00e3o com todas as suas depend\u00eancias em uma unidade padronizada para desenvolvimento de software.</p>"},{"location":"modulo4/docker-teoria/#arquitetura-do-docker","title":"Arquitetura do Docker","text":"<p>O Docker opera utilizando uma arquitetura cliente-servidor:</p> Componente Descri\u00e7\u00e3o Cita\u00e7\u00e3o Docker Daemon (<code>dockerd</code>) Servi\u00e7o em segundo plano que roda no sistema hospedeiro, escutando requisi\u00e7\u00f5es da API do Docker e gerenciando objetos Docker (como imagens, containers, redes e volumes). Docker Client (<code>docker</code>) Ferramenta de linha de comando (CLI) principal usada pelos usu\u00e1rios. Envia comandos (como <code>docker run</code>) para o daemon Docker executar. Docker Desktop Aplicativo para Mac, Windows ou Linux que inclui o Docker daemon, o cliente Docker, o Docker Compose e outras ferramentas essenciais, simplificando o processo de instala\u00e7\u00e3o e uso."},{"location":"modulo4/docker-teoria/#casos-de-uso-do-docker","title":"Casos de Uso do Docker","text":"<p>O Docker simplifica consideravelmente o ciclo de vida de desenvolvimento de software (fluxos CI/CD) ao oferecer:</p> <ul> <li>Entrega R\u00e1pida e Consistente: Desenvolvedores podem trabalhar em ambientes padronizados usando containers locais, o que facilita o compartilhamento, o teste e a implanta\u00e7\u00e3o de atualiza\u00e7\u00f5es em produ\u00e7\u00e3o.</li> <li>Escalabilidade Din\u00e2mica: A portabilidade e leveza do Docker tornam simples o gerenciamento din\u00e2mico de cargas de trabalho, permitindo escalar aplica\u00e7\u00f5es ou encerr\u00e1-las quase em tempo real.</li> <li>Efici\u00eancia: O Docker \u00e9 uma alternativa mais econ\u00f4mica a VMs baseadas em hipervisores, permitindo maior densidade de execu\u00e7\u00e3o e melhor aproveitamento da capacidade dos servidores.</li> </ul>"},{"location":"modulo4/docker-teoria/#iii-conceitos-e-terminologia-fundamentais-do-docker","title":"III. Conceitos e Terminologia Fundamentais do Docker","text":""},{"location":"modulo4/docker-teoria/#imagens","title":"Imagens","text":"<p>Imagens s\u00e3o os modelos de uma aplica\u00e7\u00e3o e formam a base dos containers. Elas s\u00e3o templates de somente leitura que cont\u00eam instru\u00e7\u00f5es e configura\u00e7\u00f5es para criar um container.</p> <ul> <li>Camadas: As imagens s\u00e3o compostas por m\u00faltiplas camadas, cada uma representando um conjunto de altera\u00e7\u00f5es no sistema de arquivos. Essa estrutura torna as imagens leves, pois apenas as camadas modificadas precisam ser reconstru\u00eddas.</li> <li>Cria\u00e7\u00e3o de Imagens: As imagens s\u00e3o criadas por meio de um Dockerfile, um arquivo de texto simples contendo uma lista de comandos (semelhantes aos comandos Linux) que automatizam o processo de constru\u00e7\u00e3o da imagem.</li> <li>Tipos: Imagens sem pai s\u00e3o chamadas de imagens base (ex.: Ubuntu, Busybox), enquanto aquelas que se constroem sobre outras s\u00e3o imagens filhas. Imagens oficialmente mantidas pelo Docker s\u00e3o imagens oficiais, e as criadas e compartilhadas por usu\u00e1rios s\u00e3o imagens de usu\u00e1rio.</li> <li>Gerenciamento de Imagens: O comando <code>docker pull</code> baixa uma imagem de um registro, e <code>docker images</code> exibe uma lista de imagens dispon\u00edveis localmente.</li> </ul>"},{"location":"modulo4/docker-teoria/#registro-docker-hub","title":"Registro (Docker Hub)","text":"<p>Um Registro Docker \u00e9 um local centralizado para armazenar e compartilhar imagens de containers.</p> <ul> <li>O Docker Hub \u00e9 o registro p\u00fablico padr\u00e3o usado pelo Docker para buscar imagens.</li> <li>Um reposit\u00f3rio \u00e9 uma cole\u00e7\u00e3o de imagens relacionadas dentro de um registro, geralmente organizadas por projeto.</li> <li>O comando <code>docker push</code> \u00e9 usado para publicar uma imagem em um registro.</li> </ul>"},{"location":"modulo4/docker-teoria/#containers-gerenciamento-via-cli","title":"Containers (Gerenciamento via CLI)","text":"<p>Containers s\u00e3o criados a partir de imagens usando o comando <code>docker run</code>.</p> <ul> <li>O comando <code>docker run</code> inicializa o container e executa um comando especificado dentro dele. A flag <code>-it</code> pode ser usada para rodar o container em modo interativo.</li> <li>O comando <code>docker ps</code> mostra todos os containers em execu\u00e7\u00e3o, enquanto <code>docker ps -a</code> exibe todos os containers, inclusive os que j\u00e1 foram encerrados.</li> <li>O comando <code>docker rm</code> \u00e9 usado para excluir containers. A flag <code>--rm</code> pode ser usada junto ao <code>docker run</code> para excluir automaticamente o container ap\u00f3s ele ser encerrado.</li> </ul>"},{"location":"modulo4/docker-teoria/#redes-do-docker","title":"Redes do Docker","text":"<p>A rede \u00e9 essencial para que aplica\u00e7\u00f5es com m\u00faltiplos containers possam se comunicar.</p> <ul> <li>A rede bridge \u00e9 a rede padr\u00e3o na qual os containers s\u00e3o executados.</li> <li>Redes bridge definidas pelo usu\u00e1rio permitem que containers conectados \u00e0 mesma rede se comuniquem entre si, permanecendo isolados de containers em outras redes.</li> <li>Quando containers s\u00e3o executados em uma rede definida pelo usu\u00e1rio, eles obt\u00eam descoberta autom\u00e1tica de servi\u00e7os, permitindo comunica\u00e7\u00e3o por nome de container (ex.: <code>es</code>) em vez de endere\u00e7os IP fixos, que podem mudar.</li> </ul>"},{"location":"modulo4/docker-teoria/#docker-compose","title":"Docker Compose","text":"<p>Docker Compose \u00e9 uma ferramenta projetada especificamente para definir e executar aplica\u00e7\u00f5es Docker com m\u00faltiplos containers.</p> <ul> <li>Configura\u00e7\u00e3o: O Compose usa um \u00fanico arquivo YAML (por exemplo, <code>docker-compose.yml</code> ou <code>compose.yaml</code>) para definir de forma declarativa todos os servi\u00e7os que comp\u00f5em a aplica\u00e7\u00e3o, junto com suas configura\u00e7\u00f5es (imagens, portas, redes, volumes).</li> <li>Execu\u00e7\u00e3o: O comando <code>docker-compose up</code> inicia todo o conjunto de servi\u00e7os e cria automaticamente uma rede para conect\u00e1-los.</li> <li>Finalidade: O Compose simplifica o gerenciamento de aplica\u00e7\u00f5es complexas, tornando-o ideal para ambientes de desenvolvimento e teste.</li> </ul>"},{"location":"modulo4/docker-teoria/#bibliografia","title":"Bibliografia","text":"<p>[1] Prakhar Srivastav Docker Curriculum. Dispon\u00edvel em: https://docker-curriculum.com/#conclusion. Acesso em: 29 out. 2025.</p> <p>[2] Docker Docs. What is docker compose?. Dispon\u00edvel em: https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-docker-compose/. Acesso em: 29 out. 2025.</p> <p>[3] Docker Docs. What is a container?. Dispon\u00edvel em: https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-a-container/. Acesso em: 29 out. 2025.</p> <p>[4] Docker Docs. What is a registry?. Dispon\u00edvel em: https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-a-registry/. Acesso em: 29 out. 2025.</p> <p>[5] Docker Docs. What is an image?. Dispon\u00edvel em: https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-an-image/. Acesso em: 29 out. 2025.</p> <p>[6] Docker Docs. Docker Overview. Dispon\u00edvel em: https://docs.docker.com/get-started/docker-overview/. Acesso em: 29 out. 2025.</p>"},{"location":"modulo4/kubernetes-pratica/","title":"Kubernetes: Pr\u00e1tica","text":""},{"location":"modulo4/kubernetes-teoria/","title":"Kubernetes: Teoria","text":""},{"location":"modulo4/monitoramento/","title":"Monitoramento com Prometheus","text":""},{"location":"modulo4/overview/","title":"M\u00f3dulo 4: Cloud Native &amp; Kubernetes - Overview","text":"<p>Este m\u00f3dulo apresenta uma introdu\u00e7\u00e3o abrangente \u00e0s tecnologias e metodologias fundamentais para desenvolvimento e deploy de aplica\u00e7\u00f5es modernas em ambiente de nuvem, com foco especial em containers, orquestra\u00e7\u00e3o e pr\u00e1ticas DevOps.</p>"},{"location":"modulo4/overview/#objetivos-do-modulo","title":"Objetivos do M\u00f3dulo","text":"<p>Ao concluir este m\u00f3dulo, os estudantes ser\u00e3o capazes de:</p> <ul> <li>Compreender os conceitos fundamentais de Cloud Native e seus benef\u00edcios</li> <li>Dominar a containeriza\u00e7\u00e3o com Docker para empacotamento de aplica\u00e7\u00f5es</li> <li>Utilizar o Kubernetes para orquestra\u00e7\u00e3o de containers em produ\u00e7\u00e3o</li> <li>Implementar pipelines de CI/CD para automa\u00e7\u00e3o de deploy</li> <li>Configurar monitoramento b\u00e1sico de aplica\u00e7\u00f5es containerizadas</li> <li>Aplicar conceitos em desafios pr\u00e1ticos reais</li> </ul>"},{"location":"modulo4/overview/#estrutura","title":"Estrutura","text":""},{"location":"modulo4/overview/#dia-04-06112025","title":"Dia 04 (06/11/2025):","text":"Conte\u00fado Hora Dura\u00e7\u00e3o 1. Recep\u00e7\u00e3o, considera\u00e7\u00f5es iniciais e avisos 13h - 13h30 30 min 2. Introdu\u00e7\u00e3o ao Cloud Native + Din\u00e2mica 13h30 - 14h30 60 min 3. Containeriza\u00e7\u00e3o com Docker + Din\u00e2mica 14h30 - 15h 30 min 4. Docker na pr\u00e1tica 15h - 15h45 45 min 5. Princ\u00edpios de CI/CD 15h45 - 16h15 30 min Intervalo + Lanche 16h15 - 16h45 30min 6. Desafio 1 16h45 - 17h45 60 min 7. Desafio 1 - Solu\u00e7\u00e3o/Corre\u00e7\u00e3o 17h45 - 18h30 45 min 8. Finaliza\u00e7\u00e3o - Dia 04 18h30 **"},{"location":"modulo4/overview/#dia-05-07112025","title":"Dia 05 (07/11/2025):","text":"Conte\u00fado Hora Dura\u00e7\u00e3o 1. Recep\u00e7\u00e3o, considera\u00e7\u00f5es iniciais e avisos 13h - 13h30 30 min 2. Kubernetes - Teoria + Din\u00e2mica 13h30 - 14h30h 60 min 3. Kubernetes - Pr\u00e1tica (Comandos b\u00e1sicos) 14h30 - 15h30 30min Intervalo + Lanche 15h30 - 16h 30min 4. Desafio 2 16h - 17h 60 min 5. Desafio 2 - Solu\u00e7\u00e3o/Corre\u00e7\u00e3o 17h - 17h45 45 min 6. Finaliza\u00e7\u00e3o do Curso 17h45 **"}]}